{
  "hash": "a280691a12160b9548a0ff7309551fe4",
  "result": {
    "markdown": "---\ntitle: 数据预处理\n---\n\n\n\n本节主要对表数据（`data.frame`）进行详解，包括增、删、查、改等单表操作，以及表之间数据关联的操作，并包含一些向量化计算的内容。\n此外还会涉及到空间数据中坐标系的转换问题。\n\n为了方便，称 `data.frame` 类型的数据，统称为“表数据”，这里“表”指数据类型，而不是文件格式。\n\n\n## 单个表数据的操作\n\n上节已经讲到，用列表示的一个或更多的数据种类，每行包含一个唯一的数据实体。\n因此，对表数据的操作将从行、列两个角度进行展开。\n我们将单个表数据的操作归为“创建、增加、查询、修改、删除”五个类型。\n\n### 创建\n\n创建一个表，是使用 `data.frame()` 函数进行的。创建表时，需要指定这个表里面有哪些列，每一列有哪些数据。例如我们使用如下语句创建一个表\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect <- data.frame(\n    name = c(\"张三\", \"李四\", \"王五\"),\n    age = c(20, 26, 30),\n    gender = c(\"M\", \"F\", \"M\"),\n    height = c(1.78, 1.65, 1.70),\n    weight = c(80, 45, 60),\n    shoe.size = c(43,38,41)\n)\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n2 李四  26      F   1.65     45        38\n3 王五  30      M   1.70     60        41\n```\n:::\n:::\n\n\n函数 `data.frame()` 具有如下参数：\n\n| 参数名 | 类型 | 含义 | 默认值 |\n| ------ | ---- | ---- | ------ |\n| `...` | 变长参数 | 每一列的值。可以指定参数名，也可以不指定。如果指定参数名，则使用参数名作为列名。 | |\n| `row.names` | integer/character/vector(integer/character)  | 指定行名 | `NULL` |\n| `check.rows` | logical | 检查列名是否符合语法、是否存在重复等问题 | `FALSE` |\n\n需要指出的是：\n\n- 每列的值不一定要是向量；如果是向量，则各列值一定要一样长。\n- 可以不指定任何列，以创建一个空表。但建议提前创建好表结构，以提高程序运行速度。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n    name = c(\"张三\", \"李四\", \"王五\"),\n    age = c(20, 26, 3),\n    gender = \"M\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender\n1 张三  20      M\n2 李四  26      M\n3 王五   3      M\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame()  # 空表数据\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata frame with 0 columns and 0 rows\n```\n:::\n:::\n\n\n### 查询\n\n查询一行或者一列，可以使用与查看矩阵相同的方法，即使用 `[]` 运算符。\n可以像矩阵一样，在 `[]` 中使用整数、序列、整型向量、逻辑型向量或者省略行列索引其中之一来获取数据。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[c(1,2), c(2,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age gender\n1  20      M\n2  26      F\n```\n:::\n:::\n\n\n对于具有列名或行名的矩阵或表数据，可以通过指定其行名、列名来获取数据\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[, c(\"name\", \"height\", \"weight\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name height weight\n1 张三   1.78     80\n2 李四   1.65     45\n3 王五   1.70     60\n```\n:::\n:::\n\n\n如果只取某一列的所有值，可以使用运算符 `$` 获取这一列的值，例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect$gender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"M\" \"F\" \"M\"\n```\n:::\n:::\n\n\n还可以使用运算符 `[[ ]]`，中间既可以填写列索引，也可以填写列名，例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[[\"gender\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"M\" \"F\" \"M\"\n```\n:::\n\n```{.r .cell-code}\ndemo.suspect[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"M\" \"F\" \"M\"\n```\n:::\n:::\n\n\n以上只是对数据简单的查找。能否像数据库一样，给数据中指定一些条件，筛选出符合条件的数据呢？答案是可以的，而且有多种方式可以做到。这里介绍三种。\n\n第一种是直接使用逻辑判断表达式，得到一组逻辑类型的向量，根据该向量获取对应位置上的元素。例如提取 `demo.suspect` 中 `gender` 列为 `M` 的行，可以这样操作\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[demo.suspect$gender == 'M',]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n3 王五  30      M   1.70     60        41\n```\n:::\n:::\n\n\n第二种是稍微有些多此一举，使用 `which()` 函数。这个函数接收一个逻辑类型的向量作为参数（如果不是向量，也会被转换成向量），返回这些向量中值为 TRUE 的元素的位置。例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(demo.suspect$gender == 'M')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3\n```\n:::\n\n```{.r .cell-code}\ndemo.suspect[which(demo.suspect$gender == 'M'),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n3 王五  30      M   1.70     60        41\n```\n:::\n:::\n\n\n第三种是使用一个强大的 `dplyr` 包，该包提供了 `select` 和 `filter` 两个函数，可以大大简化对数据的查找。\n其中，`select` 函数偏向于获取列，`filter` 函数偏向于获取行，基本对应了 SQL 语句中 `select` 和 `where` 两个子句，但提供了更多的功能。\n\n以下是一些 `select` 函数的示例\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n载入程辑包：'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nselect(demo.suspect, name)  # 获取 name 列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name\n1 张三\n2 李四\n3 王五\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(demo.suspect, c(\"height\", \"weight\", \"shoe.size\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  height weight shoe.size\n1   1.78     80        43\n2   1.65     45        38\n3   1.70     60        41\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(demo.suspect, height:shoe.size)  # 获取 height 到 shoe.size 等列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  height weight shoe.size\n1   1.78     80        43\n2   1.65     45        38\n3   1.70     60        41\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(demo.suspect, ends_with(\"ght\"))  # 获取以 \"ght\" 结尾的列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  height weight\n1   1.78     80\n2   1.65     45\n3   1.70     60\n```\n:::\n:::\n\n\n> starts_with 和 ends_with 是 `dplyr` 提供的判断字符串开头和结尾的两个函数，\n\n可以看到，该函数可以接收多种类型的参数：字符串、字符串向量、`:`表示的序列，以及一些函数返回值。\n\n以下是一些 `filter` 函数的使用示例\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(demo.suspect, name == \"张三\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(demo.suspect, gender == \"M\" & age > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 王五  30      M    1.7     60        41\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(demo.suspect, gender == \"M\", age > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 王五  30      M    1.7     60        41\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(demo.suspect, between(age, 20, 30))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n2 李四  26      F   1.65     45        38\n3 王五  30      M   1.70     60        41\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(demo.suspect, gender == \"M\", ((height * 100 - 80) * 0.7) < weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size\n1 张三  20      M   1.78     80        43\n```\n:::\n:::\n\n\n可见，该函数还是主要接收一个逻辑类型的向量作为筛选依据，可以看作是对第一种数据检索方式的简化。\n该函数也可以接收多个条件，多个条件之间是使用 `&` 运算符连接的。\n该函数还可以在列之间进行比较，也可以对列做一些运算后比较。\n该函数还支持一些函数，用于方便进行数据检索：\n\n- `between(x, L, U)` 判断变量 $x$ 的元素是否落在 $[L,U]$ 的区间内\n- `near(x, c)` 对于浮点数 $x$ 来说，直接使用 `x == c` 来判断 $x$ 和 $c$ 是否相等，会存在一些问题。该函数是用来判断 $x$ 和 $c$ 是否在浮点误差内相等。\n- `is.na(x)` 判断变量 $x$ 是否是 `NA`\n\n当然这两个函数可以进行嵌套\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(filter(demo.suspect, shoe.size < 42), \"name\":\"gender\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender\n1 李四  26      F\n2 王五  30      M\n```\n:::\n:::\n\n\n### 分组查询\n\n在 R 语言中，还可以对数据进行分组查询，相当于 SQL 中的 `group by` 子句。实现这一操作有几种方式。\n\n一种是使用 `dplyr` 包中提供的 `group_by()` 函数，该函数给数据指定一个分组依据，但不对数据进行分组处理。使用 `summarise()` 或 `summarize()` 函数进行分组处理。\n使用一次 `group_by()` 函数，数据中增加一层分组条件；使用一次 `summarise()` 函数，数据中减少一次分组条件。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(group_by(demo.suspect, gender), height.mean = mean(height), weight.mean = mean(weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  gender height.mean weight.mean\n  <chr>        <dbl>       <dbl>\n1 F             1.65          45\n2 M             1.74          70\n```\n:::\n:::\n\n\n> 这里用到了 `mean()` 和 `length()` 两个函数，其作用分别是计算平均数和向量长度。\n\n这种方式就非常类似于 SQL 语句的方式，使用起来也非常方便。\n\n另一种是使用 R 自带的 `aggregate` 函数，对数据进行聚合。例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(demo.suspect[, c(\"height\", \"weight\")], by = list(demo.suspect$gender), FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Group.1 height weight\n1       F   1.65     45\n2       M   1.74     70\n```\n:::\n:::\n\n\n该函数具有如下参数：\n\n| 参数名 | 类型 | 含义 | 默认值 |\n| ------ | ---- | ---- | ------ |\n| `x` | data.frame | 要处理的数据 | |\n| `by` | list  | 分组依据 |  |\n| `FUN` | function | 聚合函数。将每一列传入到函数的第一个参数中。 |  |\n| `...` | logical | 聚合函数的额外参数 | |\n\n这里涉及到两个类型 `list` 和 `function` ，即列表类型和函数类型。\n\n#### 列表类型\n\n列表类型，有点类似于其他编程语言的字典类型（C++ 中对应 Map 类型），是以键值对方式存在的数据。\n其中值必须有，但键名不一定必须有。当键名有时，可以比较类似于字典；当键名没有时，比较类似于任意列表。\n因此该类型的使用非常灵活，可以和 JSON 数据对应。\n\n创建列表类型变量的方式和创建表数据的方式很像，使用如下方式\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n    name = \"张三\", gender = \"Male\", age = 30, \n    children = list(\n        list(name = \"张军\", gender = \"Male\", age = 3),\n        list(name = \"张灵\", gender = \"Female\", age = 2)\n    ),\n    interests = c(\"体育\", \"音乐\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n[1] \"张三\"\n\n$gender\n[1] \"Male\"\n\n$age\n[1] 30\n\n$children\n$children[[1]]\n$children[[1]]$name\n[1] \"张军\"\n\n$children[[1]]$gender\n[1] \"Male\"\n\n$children[[1]]$age\n[1] 3\n\n\n$children[[2]]\n$children[[2]]$name\n[1] \"张灵\"\n\n$children[[2]]$gender\n[1] \"Female\"\n\n$children[[2]]$age\n[1] 2\n\n\n\n$interests\n[1] \"体育\" \"音乐\"\n```\n:::\n:::\n\n\n事实上，`data.frame` 类型只是一个特殊的 `list` 类型，特殊在不同键的值具有相同的长度。\n\n在 `aggregrate` 函数中，如果 `by` 参数传入的列表只有几个键值对，那么就按照这几个条件进行分组。多个条件分组的示例如下\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(demo.suspect[, c(\"height\", \"weight\")], by = list(demo.suspect$gender), FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Group.1 height weight\n1       F   1.65     45\n2       M   1.74     70\n```\n:::\n:::\n\n\n#### 函数类型\n\nR 中，函数也是一个变量，即函数类型的变量（有点 JavaScript 那味了），但是 `()` 运算符只能作用于函数类型的变量上。\n\n创建函数类型的变量使用 `function` 关键字，将最后一条运行的语句的结果作为返回值。例如，创建一个计算二次函数值的变量\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadratic <- function(x, a = 1, b = 0, c = 0) {\n    (a * x^2 + b * x + c)\n}\nquadratic(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nquadratic(1, 1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nquadratic(1, 1, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nR 语言中的函数无需使用 `return` 指明返回值， `return()` 也是一个函数，但其只起到控制函数流程的作用。\n\nR 语言中也提供了丰富的函数，用于进行简单的统计计算，包括 `mean()`, `sd()`, `var()`, `min()`, `max()`, `median()`, `length()`, `range()`, `quantile()`, `fivenum()` 等。\n这些函数可以直接使用。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:5)       # 平均数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nsd(1:5)         # 标准差\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.581139\n```\n:::\n\n```{.r .cell-code}\nvar(1:5)        # 方差\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n\n```{.r .cell-code}\nmin(1:5)        # 最小值\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmax(1:5)        # 最大值\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmedian(1:5)     # 中位数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(1:5)     # 长度\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nrange(1:5)      # 极值\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5\n```\n:::\n\n```{.r .cell-code}\nquantile(1:10)  # 四分位数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   0%   25%   50%   75%  100% \n 1.00  3.25  5.50  7.75 10.00 \n```\n:::\n\n```{.r .cell-code}\nfivenum(1:10)   # 四分位数（与上一种算法不同）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0  3.0  5.5  8.0 10.0\n```\n:::\n:::\n\n\n#### 判断语句\n\n在之前可以看到，我们调用 `mean` 作为统计函数的时候，如果遇到字符串或逻辑值，其统计结果是有问题的。这时就需要我们使用自定义的函数，对不同类类型的列进行处理\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(demo.suspect, by = list(demo.suspect$gender), FUN = function(x) {\n    if (class(x) == \"character\") {\n        length(x)\n    } else if (class(x) == \"logical\") {\n        length(which(x))\n    } else {\n        mean(x)\n    }\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Group.1 name age gender height weight shoe.size\n1       F    1  26      1   1.65     45        38\n2       M    2  25      2   1.74     70        42\n```\n:::\n:::\n\n\n这里使用到了 `if` `else` 关键字进行函数流程的控制。\n`if` 关键字后面使用 `()` 包含一个逻辑表达式表示条件，当该条件成立时执行 `{}` 中的语句；不成立时，如果有 `else` 则执行 `else` 后 `{}` 的语句。\n\n#### 循环语句\n。\n与其它语言类似，R 语言中也有 `for` `while` 两种循环语句。这里顺便介绍一下。\n\n`for` 语句的用法是\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in demo.suspect$height) {\n    print(i * 100)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 178\n[1] 165\n[1] 170\n```\n:::\n:::\n\n\n> 这里的 `print()` 函数将变量进行输出。\n\n`while` 语句的用法是\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 2\nwhile (i > 0.0001) {\n    i <- i / 2\n}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.103516e-05\n```\n:::\n:::\n\n\n需要指出的是，R 语言执行 `for` `while` 循环的效率比较低，因此不建议大量使用循环语句，推荐使用向量化计算方法，即将循环对象作为一个向量进行整体计算。\n如果一定要对每一个值单独进行处理，在 R 中也有更高效的方法。\n\n### 增加\n\n对数据增加一列，可以使用 `$` 运算符或者 `[[]]` 运算符，只要这一列的名字没有在数据中出现，直接赋值即可。新增的列出现在最后面。例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect0 <- demo.suspect # 备份一下\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect$married <- c(T, T, F)\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size married\n1 张三  20      M   1.78     80        43    TRUE\n2 李四  26      F   1.65     45        38    TRUE\n3 王五  30      M   1.70     60        41   FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[[\"children.count\"]] <- c(2, 1, 0)\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size married children.count\n1 张三  20      M   1.78     80        43    TRUE              2\n2 李四  26      F   1.65     45        38    TRUE              1\n3 王五  30      M   1.70     60        41   FALSE              0\n```\n:::\n:::\n\n\n我们也可以将一些计算值加入到列中，例如计算 BMI 指数\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect$BMI <- demo.suspect$weight / demo.suspect$height^2\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size married children.count      BMI\n1 张三  20      M   1.78     80        43    TRUE              2 25.24934\n2 李四  26      F   1.65     45        38    TRUE              1 16.52893\n3 王五  30      M   1.70     60        41   FALSE              0 20.76125\n```\n:::\n:::\n\n\n以上这些操作，都可以使用一个函数 `transform()` 完成，该函数的用法类似于 `select` `filter` 两个函数，在后面可以直接指定新列的值\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform(demo.suspect0, BMI = weight / height^2, married = c(T, T, F), children.count = c(2, 1, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size      BMI married children.count\n1 张三  20      M   1.78     80        43 25.24934    TRUE              2\n2 李四  26      F   1.65     45        38 16.52893    TRUE              1\n3 王五  30      M   1.70     60        41 20.76125   FALSE              0\n```\n:::\n:::\n\n\n增加列的操作是比较简单的。对于增加行的操作，由于不同列的数据类型不同，因此比较复杂。\n\n如果有行名，可以使用 `[行名,列名]` 的方式，指定一个新行名的索引，填入数据即可。\n建议分别赋值，可保证列不改变。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(demo.suspect0) <- demo.suspect0$name\ndemo.suspect0[\"赵六\", \"name\"] <- \"赵六\"\ndemo.suspect0[\"赵六\", \"age\"] <- 29\ndemo.suspect0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name age gender height weight shoe.size\n张三 张三  20      M   1.78     80        43\n李四 李四  26      F   1.65     45        38\n王五 王五  30      M   1.70     60        41\n赵六 赵六  29   <NA>     NA     NA        NA\n```\n:::\n:::\n\n\n如果没有行名，可以使用函数 `nrow()` 计算以下当前的行数 $r$，使用 `[r+1,列名]` 的方式填入数据。\n\n还可以使用 `rbind()` 函数增加一行，使用方法如下\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect <- rbind(demo.suspect, data.frame(\n    name = \"赵六\",\n    age = 19,\n    gender = \"F\",\n    height = 1.6,\n    weight = 43,\n    shoe.size = 37,\n    BMI = 43 / 1.6^2,\n    married = F,\n    children.count = 0\n))\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size married children.count      BMI\n1 张三  20      M   1.78     80        43    TRUE              2 25.24934\n2 李四  26      F   1.65     45        38    TRUE              1 16.52893\n3 王五  30      M   1.70     60        41   FALSE              0 20.76125\n4 赵六  19      F   1.60     43        37   FALSE              0 16.79687\n```\n:::\n:::\n\n\n但该函数效率较低，应尽量避免使用。同样地，R 中也有一个 `cbind` 函数，其用法和 rbind 类似，只是用于增加列，但该函数效率也比较低，因此不推荐使用。\n\n### 修改\n\n该部分所说的改，包括对名、类型、值的修改。\n\n修改表数据列名和行名的方法和矩阵是类似的，都是使用 `row.names()` 和 `col.names()` 两个函数进行的。值得注意的是，不一定一次要全部修改。例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(demo.suspect)[7] <- \"is.married\"\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size is.married children.count      BMI\n1 张三  20      M   1.78     80        43       TRUE              2 25.24934\n2 李四  26      F   1.65     45        38       TRUE              1 16.52893\n3 王五  30      M   1.70     60        41      FALSE              0 20.76125\n4 赵六  19      F   1.60     43        37      FALSE              0 16.79687\n```\n:::\n:::\n\n\n修改类型，特指修改列的类型，方法还是使用 as 族函数，通过对一列进行整体操作，例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect$age <- as.integer(demo.suspect$age)\ndemo.suspect$children.count <- as.integer(demo.suspect$children.count)\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size is.married children.count      BMI\n1 张三  20      M   1.78     80        43       TRUE              2 25.24934\n2 李四  26      F   1.65     45        38       TRUE              1 16.52893\n3 王五  30      M   1.70     60        41      FALSE              0 20.76125\n4 赵六  19      F   1.60     43        37      FALSE              0 16.79687\n```\n:::\n:::\n\n\n修改值的方法和修改类型的方法基本一样，例如如果给 age 整体增 1，可以使用以下方式\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect$age <- demo.suspect$age + 1\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size is.married children.count      BMI\n1 张三  21      M   1.78     80        43       TRUE              2 25.24934\n2 李四  27      F   1.65     45        38       TRUE              1 16.52893\n3 王五  31      M   1.70     60        41      FALSE              0 20.76125\n4 赵六  20      F   1.60     43        37      FALSE              0 16.79687\n```\n:::\n:::\n\n\n当然也可以对某一个值单独进行赋值，例如将 `王五` 的 `is.married` 列的值修改为 `T`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[demo.suspect$name == \"王五\", \"is.married\"] <- T\ndemo.suspect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size is.married children.count      BMI\n1 张三  21      M   1.78     80        43       TRUE              2 25.24934\n2 李四  27      F   1.65     45        38       TRUE              1 16.52893\n3 王五  31      M   1.70     60        41       TRUE              0 20.76125\n4 赵六  20      F   1.60     43        37      FALSE              0 16.79687\n```\n:::\n:::\n\n\n与增操作类似，一般不对行进行整体的改操作。\n\n#### 删\n\n删除一行或者一列的方法，等价于选择另外一些行或者列。例如如果要删除 `children.count` 这一列，或者删除 `children.count` 这一列的值小于 1 的，只需要选择其他列，即可。\n而如果列比较多，要删的列只有一两个，进行查询操作并不是很方便。此时可以使用负整数索引进行删除。例如\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.suspect[-c(4),-c(8)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size is.married      BMI\n1 张三  21      M   1.78     80        43       TRUE 25.24934\n2 李四  27      F   1.65     45        38       TRUE 16.52893\n3 王五  31      M   1.70     60        41       TRUE 20.76125\n```\n:::\n:::\n\n\n此外，如果知道列名， `transform` 函数也可以用于删除列，只需要将该列的值设置为 `NULL` 即可\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform(demo.suspect, is.married = NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name age gender height weight shoe.size children.count      BMI\n1 张三  21      M   1.78     80        43              2 25.24934\n2 李四  27      F   1.65     45        38              1 16.52893\n3 王五  31      M   1.70     60        41              0 20.76125\n4 赵六  20      F   1.60     43        37              0 16.79687\n```\n:::\n:::\n\n\n### 多个表的操作\n\n很多时候，不同部分的数据是分别收集的，会形成多个表数据。对于这种情况，在数据处理时，就需要将两张表进行连接。\n使用原生 R 的语句可以做到这一点，但是会比较麻烦。这里还是主要介绍 `dplyr` 包中提供的方法。\n\n先创建一个新的数据集，使用的数据是 R 中自带的，主要是关于美国各州的一些情况。此外还需要用到一个自带的表数据 `USArrests`。 \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates.info <- data.frame(name = state.name, abb = state.abb, state.center, area = state.area)\nstates.arrests <- USArrests[4:20,]\nstates.arrests$name <- rownames(states.arrests)\nhead(states.info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        name abb         x       y   area\n1    Alabama  AL  -86.7509 32.5901  51609\n2     Alaska  AK -127.2500 49.2500 589757\n3    Arizona  AZ -111.6250 34.2192 113909\n4   Arkansas  AR  -92.2992 34.7336  53104\n5 California  CA -119.7730 36.5341 158693\n6   Colorado  CO -105.5130 38.6777 104247\n```\n:::\n\n```{.r .cell-code}\nhead(states.arrests)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Murder Assault UrbanPop Rape        name\nArkansas       8.8     190       50 19.5    Arkansas\nCalifornia     9.0     276       91 40.6  California\nColorado       7.9     204       78 38.7    Colorado\nConnecticut    3.3     110       77 11.1 Connecticut\nDelaware       5.9     238       72 15.8    Delaware\nFlorida       15.4     335       80 31.9     Florida\n```\n:::\n:::\n\n\n> 由于 `data.frame` 是一个特殊的 `list`，创建 `data.frame` 时也可以直接传入 `list` 数据，该 `list` 中的每一个值的要求，和对其他字段的要求相同。\n\n下面我们需要将这两个表进行关联。如果两个数据是一一对应的，可以直接使用 `cbind()` 函数。\n但这与这种数据，显然不是，就需要使用进行连接操作，使用到的函数主要有四种：\n\n- `inner_join()`：只保留两者完全匹配到的记录\n- `left_join()`：保留左边所有记录\n- `right_join()`：保留右边所有记录\n- `full_join()`：保留两边所有记录\n\n这几个函数接受的参数是一样的。\n\n\n::: {.cell scrolled='true'}\n\n```{.r .cell-code}\ninner_join(states.info, states.arrests, by = c(\"name\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          name abb         x       y   area Murder Assault UrbanPop Rape\n1     Arkansas  AR  -92.2992 34.7336  53104    8.8     190       50 19.5\n2   California  CA -119.7730 36.5341 158693    9.0     276       91 40.6\n3     Colorado  CO -105.5130 38.6777 104247    7.9     204       78 38.7\n4  Connecticut  CT  -72.3573 41.5928   5009    3.3     110       77 11.1\n5     Delaware  DE  -74.9841 38.6777   2057    5.9     238       72 15.8\n6      Florida  FL  -81.6850 27.8744  58560   15.4     335       80 31.9\n7      Georgia  GA  -83.3736 32.3329  58876   17.4     211       60 25.8\n8       Hawaii  HI -126.2500 31.7500   6450    5.3      46       83 20.2\n9        Idaho  ID -113.9300 43.5648  83557    2.6     120       54 14.2\n10    Illinois  IL  -89.3776 40.0495  56400   10.4     249       83 24.0\n11     Indiana  IN  -86.0808 40.0495  36291    7.2     113       65 21.0\n12        Iowa  IA  -93.3714 41.9358  56290    2.2      56       57 11.3\n13      Kansas  KS  -98.1156 38.4204  82264    6.0     115       66 18.0\n14    Kentucky  KY  -84.7674 37.3915  40395    9.7     109       52 16.3\n15   Louisiana  LA  -92.2724 30.6181  48523   15.4     249       66 22.2\n16       Maine  ME  -68.9801 45.6226  33215    2.1      83       51  7.8\n17    Maryland  MD  -76.6459 39.2778  10577   11.3     300       67 27.8\n```\n:::\n:::\n\n::: {.cell scrolled='true'}\n\n```{.r .cell-code}\nleft_join(states.info, states.arrests, by = c(\"name\" = \"name\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             name abb         x       y   area Murder Assault UrbanPop Rape\n1         Alabama  AL  -86.7509 32.5901  51609     NA      NA       NA   NA\n2          Alaska  AK -127.2500 49.2500 589757     NA      NA       NA   NA\n3         Arizona  AZ -111.6250 34.2192 113909     NA      NA       NA   NA\n4        Arkansas  AR  -92.2992 34.7336  53104    8.8     190       50 19.5\n5      California  CA -119.7730 36.5341 158693    9.0     276       91 40.6\n6        Colorado  CO -105.5130 38.6777 104247    7.9     204       78 38.7\n7     Connecticut  CT  -72.3573 41.5928   5009    3.3     110       77 11.1\n8        Delaware  DE  -74.9841 38.6777   2057    5.9     238       72 15.8\n9         Florida  FL  -81.6850 27.8744  58560   15.4     335       80 31.9\n10        Georgia  GA  -83.3736 32.3329  58876   17.4     211       60 25.8\n11         Hawaii  HI -126.2500 31.7500   6450    5.3      46       83 20.2\n12          Idaho  ID -113.9300 43.5648  83557    2.6     120       54 14.2\n13       Illinois  IL  -89.3776 40.0495  56400   10.4     249       83 24.0\n14        Indiana  IN  -86.0808 40.0495  36291    7.2     113       65 21.0\n15           Iowa  IA  -93.3714 41.9358  56290    2.2      56       57 11.3\n16         Kansas  KS  -98.1156 38.4204  82264    6.0     115       66 18.0\n17       Kentucky  KY  -84.7674 37.3915  40395    9.7     109       52 16.3\n18      Louisiana  LA  -92.2724 30.6181  48523   15.4     249       66 22.2\n19          Maine  ME  -68.9801 45.6226  33215    2.1      83       51  7.8\n20       Maryland  MD  -76.6459 39.2778  10577   11.3     300       67 27.8\n21  Massachusetts  MA  -71.5800 42.3645   8257     NA      NA       NA   NA\n22       Michigan  MI  -84.6870 43.1361  58216     NA      NA       NA   NA\n23      Minnesota  MN  -94.6043 46.3943  84068     NA      NA       NA   NA\n24    Mississippi  MS  -89.8065 32.6758  47716     NA      NA       NA   NA\n25       Missouri  MO  -92.5137 38.3347  69686     NA      NA       NA   NA\n26        Montana  MT -109.3200 46.8230 147138     NA      NA       NA   NA\n27       Nebraska  NE  -99.5898 41.3356  77227     NA      NA       NA   NA\n28         Nevada  NV -116.8510 39.1063 110540     NA      NA       NA   NA\n29  New Hampshire  NH  -71.3924 43.3934   9304     NA      NA       NA   NA\n30     New Jersey  NJ  -74.2336 39.9637   7836     NA      NA       NA   NA\n31     New Mexico  NM -105.9420 34.4764 121666     NA      NA       NA   NA\n32       New York  NY  -75.1449 43.1361  49576     NA      NA       NA   NA\n33 North Carolina  NC  -78.4686 35.4195  52586     NA      NA       NA   NA\n34   North Dakota  ND -100.0990 47.2517  70665     NA      NA       NA   NA\n35           Ohio  OH  -82.5963 40.2210  41222     NA      NA       NA   NA\n36       Oklahoma  OK  -97.1239 35.5053  69919     NA      NA       NA   NA\n37         Oregon  OR -120.0680 43.9078  96981     NA      NA       NA   NA\n38   Pennsylvania  PA  -77.4500 40.9069  45333     NA      NA       NA   NA\n39   Rhode Island  RI  -71.1244 41.5928   1214     NA      NA       NA   NA\n40 South Carolina  SC  -80.5056 33.6190  31055     NA      NA       NA   NA\n41   South Dakota  SD  -99.7238 44.3365  77047     NA      NA       NA   NA\n42      Tennessee  TN  -86.4560 35.6767  42244     NA      NA       NA   NA\n43          Texas  TX  -98.7857 31.3897 267339     NA      NA       NA   NA\n44           Utah  UT -111.3300 39.1063  84916     NA      NA       NA   NA\n45        Vermont  VT  -72.5450 44.2508   9609     NA      NA       NA   NA\n46       Virginia  VA  -78.2005 37.5630  40815     NA      NA       NA   NA\n47     Washington  WA -119.7460 47.4231  68192     NA      NA       NA   NA\n48  West Virginia  WV  -80.6665 38.4204  24181     NA      NA       NA   NA\n49      Wisconsin  WI  -89.9941 44.5937  56154     NA      NA       NA   NA\n50        Wyoming  WY -107.2560 43.0504  97914     NA      NA       NA   NA\n```\n:::\n:::\n\n\n这些函数中，前两个参数显然就是要连接的两张表，第一个参数是左表，第二个参数是右表。参数 `by` 就是连接条件。\n该参数可以有多种形式：\n\n- 用 `c` 函数创建一组键值对，键表示第一张表的连接字段，值表示第二张表的连接字段。\n- 字符串向量，在两张表中找字符串中的字段进行连接。\n- `NULL` ，函数在两张表中寻找同名字段进行连接。\n\n连接后的表包含了两张表的所有字段，如果字段有重名，那么会在字段后面加上后缀，默认是 `.x` `.y` ，但是也可以通过 `suffix` 参数进行控制。这里具体就不再进行演示了。\n\n## 向量化计算\n\n之前提到，R 语言中执行循环的效率是比较低的，提高效率的方法就是向量化计算，即以向量为单位进行计算。\n如果向量之间各元素的操作相同，且比较简单，那么可以直接使用向量运算来进行，这是最为推荐的方式。\n但是如果向量计算的操作比较复杂，这时就需要用到 `apply` 族函数了。这些函数主要包括以下几个：\n\n- `apply` 针对矩阵进行计算\n- `lapply` 针对列表进行计算\n- `sapply` 针对列表进行计算，结果会进行自动化简\n- `vapply` 针对向量进行计算，\n- ...\n\n例如，我们现在有一个 $n \\times n$ 的距离矩阵（这里使用 `dist` 函数生成，也可以从外部导入），我们需要找到每一列中排名第 20 的距离值。就可以使用 apply 函数进行计算。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance.mat <- as.matrix(dist(states.info[, c(\"x\", \"y\")]))\ndim(distance.mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50 50\n```\n:::\n\n```{.r .cell-code}\napply(X = distance.mat, MARGIN = 2, FUN = function(d) {\n    sort(d)[20]\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        1         2         3         4         5         6         7         8 \n12.094518 33.603671 19.549402 11.886354 26.948522 15.466156 14.391130 11.181171 \n        9        10        11        12        13        14        15        16 \n15.055850 10.934488 33.996448 19.531737 10.957359 10.625749 11.854740 12.772972 \n       17        18        19        20        21        22        23        24 \n 9.867485 14.160086 19.590533  9.950928 15.482958 10.882746 14.721943 11.665156 \n       25        26        27        28        29        30        31        32 \n10.934488 18.685776 13.570082 23.410054 16.305944 11.906667 16.235656 13.549304 \n       33        34        35        36        37        38        39        40 \n 9.910319 15.952050 10.330487 12.499634 25.584814 10.414558 15.355411 11.400714 \n       41        42        43        44        45        46        47        48 \n15.084638 10.414558 15.375520 18.244560 16.102637  8.963470 26.389469  9.997616 \n       49        50 \n13.074668 15.478154 \n```\n:::\n:::\n\n\n该函数具有如下参数：\n\n| 参数名 | 类型 | 含义 | 默认值 |\n| ------ | ---- | ---- | ------ |\n| `X` | matrix | 要处理的数据 | |\n| `MARGIN` | integer  | 处理的维度。取 1 时，表示对每一行进行处理。取 2 时，表示对每一列进行处理。 |  |\n| `FUN` | function | 执行函数。根据 `MARGIN` 将每一行或每一列作为第一个参数传入。 |  |\n| `...` | logical | 执行函数的额外参数。 | |\n\n函数在返回时，每一次执行函数的结果进行组合。如果执行的结果是数量，则组合成一个向量。如果执行的结果是向量，则作为一列组合成一个矩阵。\n\n在第一节中，我们读取了一个表数据，但是有些字段应该是浮点数，系统判断成了字符串类型；有些是整数，系统默认为浮点数。\n对于这种情况，我们就可以使用 `lapply` 对其进行转换\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo.table <- read.csv(\"data/LNHP03.csv\")\ndemo.table[,c(\"X\", \"Y\")] <- lapply(demo.table[,c(\"X\", \"Y\")], as.numeric)\ndemo.table[,c(\"PURCHASE\", \"FLOORSZ\")] <- lapply(demo.table[,c(\"PURCHASE\", \"FLOORSZ\")], as.integer)\nhead(demo.table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       X      Y PURCHASE FLOORSZ TYPETRRD TYPEBNGLW TYPEFLAT BLDPWW1 BLDPOSTW\n1 531200 157700   215000     100        0         0        0       0        0\n2 530400 158300   207500     100        0         0        0       0        0\n3 530100 158700   270000     180        0         0        0       0        0\n4 541300 159100   176000     125        0         0        0       0        0\n5 541500 159100    77750      76        0         0        1       0        0\n6 542000 159300   135000     101        0         0        0       0        0\n  BLD60S BLD70S BLD80S BATH2 BEDS2 GARAGE1 CENTHEAT UNEMPLOY     PROF BLDINTW\n1      0      0      0     0     1       1        1 3.346160 41.12903       1\n2      0      0      0     0     1       1        1 3.346160 41.12903       1\n3      0      0      0     0     1       0        1 3.346160 41.12903       1\n4      0      1      0     1     1       0        1 2.547548 43.79504       0\n5      0      0      1     0     1       0        1 2.547548 43.79504       0\n6      1      0      0     0     1       1        1 2.547548 43.79504       0\n```\n:::\n:::\n\n\n如果我们要取 `PURCHASE` `UNEMPLOY` `PROF` 三列中各自最大的 6 个值，可以使用如下方法\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(demo.table[, c(\"PURCHASE\", \"FLOORSZ\", \"PROF\")], function (x) {\n    head(sort(x, decreasing = T))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$PURCHASE\n[1] 740000 735000 675000 650000 567500 525000\n\n$FLOORSZ\n[1] 277 276 270 260 259 250\n\n$PROF\n[1] 71.25000 66.74260 66.23134 66.19733 66.19733 66.19733\n```\n:::\n:::\n\n\n可见 `lapply` 处理的是列表，返回的也是列表。可以使用 `sapply` 对输出结果进行自动简化，生成更易于观察的结果\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(demo.table[, c(\"PURCHASE\", \"FLOORSZ\", \"PROF\")], function (x) {\n    head(sort(x, decreasing = T))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     PURCHASE FLOORSZ     PROF\n[1,]   740000     277 71.25000\n[2,]   735000     276 66.74260\n[3,]   675000     270 66.23134\n[4,]   650000     260 66.19733\n[5,]   567500     259 66.19733\n[6,]   525000     250 66.19733\n```\n:::\n:::\n\n\n对于 `vapply` 这里就不再过多介绍了，其效果和 `lapply` 类似，只是接收一个向量。\n\n## 空间数据操作\n\n对于空间数据的操作，可以分成两类：\n\n1. 对属性进行操作。这个操作方法和之前所讲的对表数据的操作方法相同，只是操作的对象是 `@data` 插槽中的值。\n2. 对几何进行操作。这类操作有很多，相交、合并、投影……这里就不一一介绍。但这里主要讲一个操作——坐标系转换。\n\n### 坐标系转换\n\n坐标系转换，在 ArcGIS 中称作“投影”，就是把空间数据在一个坐标系下的坐标转换为另一种坐标系下的坐标。常用的有几种坐标：\n\n这一操作主要使用 `rgdal` 包中的 `spTransform` 进行实现。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgdal)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n载入需要的程辑包：sp\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPlease note that rgdal will be retired during October 2023,\nplan transition to sf/stars/terra functions using GDAL and PROJ\nat your earliest convenience.\nSee https://r-spatial.org/r/2023/05/15/evolution4.html and https://github.com/r-spatial/evolution\nrgdal: version: 1.6-7, (SVN revision 1203)\nGeospatial Data Abstraction Library extensions to R successfully loaded\nLoaded GDAL runtime: GDAL 3.5.3, released 2022/10/21\nPath to GDAL shared files: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/rgdal/gdal\n GDAL does not use iconv for recoding strings.\nGDAL binary built with GEOS: TRUE \nLoaded PROJ runtime: Rel. 9.1.0, September 1st, 2022, [PJ_VERSION: 910]\nPath to PROJ shared files: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/rgdal/proj\nPROJ CDN enabled: TRUE\nLinking to sp version:1.6-1\nTo mute warnings of possible GDAL/OSR exportToProj4() degradation,\nuse options(\"rgdal_show_exportToProj4_warnings\"=\"none\") before loading sp or rgdal.\n```\n:::\n\n```{.r .cell-code}\n# 读取数据\ndemo.shp <- readOGR(\"data/LNHP03.shp\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: OGR support is provided by the sf and terra packages among others\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nOGR data source with driver: ESRI Shapefile \nSource: \"/Users/yigong/Documents/RTraining/data/LNHP03.shp\", layer: \"LNHP03\"\nwith 2108 features\nIt has 17 fields\n```\n:::\n\n```{.r .cell-code}\nhead(demo.shp@coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     coords.x1 coords.x2\n[1,]    531200    157700\n[2,]    530400    158300\n[3,]    530100    158700\n[4,]    541300    159100\n[5,]    541500    159100\n[6,]    542000    159300\n```\n:::\n\n```{.r .cell-code}\n# 投影转换\ndemo.shp.wgs84 <- spTransform(demo.shp, CRS(\"+proj=longlat +datum=WGS84 +no_defs\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: PROJ support is provided by the sf and terra packages among others\n```\n:::\n\n```{.r .cell-code}\nhead(demo.shp.wgs84@coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       coords.x1 coords.x2\n[1,] -0.11928715  51.30331\n[2,] -0.13053817  51.30888\n[3,] -0.13469422  51.31255\n[4,]  0.02605949  51.31347\n[5,]  0.02892724  51.31342\n[6,]  0.03617622  51.31510\n```\n:::\n:::\n\n\n该函数接收两个参数，第一个参数是要转换的 `Spatial*DataFrame` 数据；第二个参数是转换到的坐标系，是 `CRS()` 函数返回的对象。\n函数 `CRS()` 接收一个 Proj4 格式的字符串，不同坐标系对应的 Proj4 字符串可在 EPSG 官网上进行查询。\n\n关于其他空间操作，详见《R 语言空间数据处理与分析实践教程》。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}